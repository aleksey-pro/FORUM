{"version":3,"sources":["ColladaLoader.js","Detector.js","OrbitControls.js","stats.min.js","logo.js","scripts.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxiHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnhCA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"custom.js","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\r\nTHREE.ColladaLoader = function( manager ) {\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\r\n};\n\r\nTHREE.ColladaLoader.prototype = {\n\r\n\tconstructor: THREE.ColladaLoader,\n\r\n\tcrossOrigin: 'Anonymous',\n\r\n\tload: function( url, onLoad, onProgress, onError ) {\n\r\n\t\tlet scope = this;\n\r\n\t\tlet path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\r\n\t\tlet loader = new THREE.FileLoader( scope.manager );\n\t\tloader.load( url, function( text ) {\n\r\n\t\t\tonLoad( scope.parse( text, path ) );\n\r\n\t\t}, onProgress, onError );\n\r\n\t},\n\r\n\tsetPath: function( value ) {\n\r\n\t\tthis.path = value;\n\r\n\t},\n\r\n\toptions: {\n\r\n\t\tset convertUpAxis( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\r\n\t\t},\r\n\n\t},\n\r\n\tsetCrossOrigin: function( value ) {\n\r\n\t\tthis.crossOrigin = value;\n\r\n\t},\n\r\n\tparse: function( text, path ) {\n\r\n\t\tfunction getElementsByTagName( xml, name ) {\n\r\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\r\n\t\t\tlet array = [];\n\t\t\tlet childNodes = xml.childNodes;\n\r\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = childNodes[i];\n\r\n\t\t\t\tif ( child.nodeName === name ) {\n\r\n\t\t\t\t\tarray.push( child );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn array;\n\r\n\t\t}\n\r\n\t\tfunction parseStrings( text ) {\n\r\n\t\t\tif ( text.length === 0 ) return [];\n\r\n\t\t\tlet parts = text.trim().split( /\\s+/ );\n\t\t\tlet array = new Array( parts.length );\n\r\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\r\n\t\t\t\tarray[i] = parts[i];\n\r\n\t\t\t}\n\r\n\t\t\treturn array;\n\r\n\t\t}\n\r\n\t\tfunction parseFloats( text ) {\n\r\n\t\t\tif ( text.length === 0 ) return [];\n\r\n\t\t\tlet parts = text.trim().split( /\\s+/ );\n\t\t\tlet array = new Array( parts.length );\n\r\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\r\n\t\t\t\tarray[i] = parseFloat( parts[i] );\n\r\n\t\t\t}\n\r\n\t\t\treturn array;\n\r\n\t\t}\n\r\n\t\tfunction parseInts( text ) {\n\r\n\t\t\tif ( text.length === 0 ) return [];\n\r\n\t\t\tlet parts = text.trim().split( /\\s+/ );\n\t\t\tlet array = new Array( parts.length );\n\r\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\r\n\t\t\t\tarray[i] = parseInt( parts[i] );\n\r\n\t\t\t}\n\r\n\t\t\treturn array;\n\r\n\t\t}\n\r\n\t\tfunction parseId( text ) {\n\r\n\t\t\treturn text.substring( 1 );\n\r\n\t\t}\n\r\n\t\tfunction generateId() {\n\r\n\t\t\treturn 'three_default_' + ( count ++ );\n\r\n\t\t}\n\r\n\t\tfunction isEmpty( object ) {\n\r\n\t\t\treturn Object.keys( object ).length === 0;\n\r\n\t\t}\n\r\n\t\t// asset\n\r\n\t\tfunction parseAsset( xml ) {\n\r\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[0] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[0] ),\r\n\t\t\t};\n\r\n\t\t}\n\r\n\t\tfunction parseAssetUnit( xml ) {\n\r\n\t\t\treturn xml !== undefined ? parseFloat( xml.getAttribute( 'meter' ) ) : 1;\n\r\n\t\t}\n\r\n\t\tfunction parseAssetUpAxis( xml ) {\n\r\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\r\n\t\t}\n\r\n\t\t// library\n\r\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\r\n\t\t\tlet library = getElementsByTagName( xml, libraryName )[0];\n\r\n\t\t\tif ( library !== undefined ) {\n\r\n\t\t\t\tlet elements = getElementsByTagName( library, nodeName );\n\r\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\r\n\t\t\t\t\tparser( elements[i] );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction buildLibrary( data, builder ) {\n\r\n\t\t\tfor ( let name in data ) {\n\r\n\t\t\t\tlet object = data[name];\n\t\t\t\tobject.build = builder( data[name] );\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t// get\n\r\n\t\tfunction getBuild( data, builder ) {\n\r\n\t\t\tif ( data.build !== undefined ) return data.build;\n\r\n\t\t\tdata.build = builder( data );\n\r\n\t\t\treturn data.build;\n\r\n\t\t}\n\r\n\t\t// animation\n\r\n\t\tfunction parseAnimation( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tvar id;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[id] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[id] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[id] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.animations[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseAnimationSampler( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[semantic] = id;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseAnimationChannel( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tlet target = xml.getAttribute( 'target' );\n\r\n\t\t\t// parsing SID Addressing Syntax\n\r\n\t\t\tlet parts = target.split( '/' );\n\r\n\t\t\tlet id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\r\n\t\t\t// check selection syntax\n\r\n\t\t\tlet arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tlet memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\r\n\t\t\tif ( memberSyntax ) {\n\r\n\t\t\t\t//  member selection access\n\r\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\r\n\t\t\t} else if ( arraySyntax ) {\n\r\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\r\n\t\t\t\tlet indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\r\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\r\n\t\t\t\t\tindices[i] = parseInt( indices[i].replace( /\\)/, '' ) );\n\r\n\t\t\t\t}\n\r\n\t\t\t\tdata.indices = indices;\n\r\n\t\t\t}\n\r\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\r\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\r\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildAnimation( data ) {\n\r\n\t\t\tlet tracks = [];\n\r\n\t\t\tlet channels = data.channels;\n\t\t\tlet samplers = data.samplers;\n\t\t\tlet sources = data.sources;\n\r\n\t\t\tfor ( let target in channels ) {\n\r\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\r\n\t\t\t\t\tlet channel = channels[target];\n\t\t\t\t\tlet sampler = samplers[channel.sampler];\n\r\n\t\t\t\t\tlet inputId = sampler.inputs.INPUT;\n\t\t\t\t\tlet outputId = sampler.inputs.OUTPUT;\n\r\n\t\t\t\t\tlet inputSource = sources[inputId];\n\t\t\t\t\tlet outputSource = sources[outputId];\n\r\n\t\t\t\t\tlet animation = buildAnimationChannel( channel, inputSource, outputSource );\n\r\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn tracks;\n\r\n\t\t}\n\r\n\t\tfunction getAnimation( id ) {\n\r\n\t\t\treturn getBuild( library.animations[id], buildAnimation );\n\r\n\t\t}\n\r\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\r\n\t\t\tlet node = library.nodes[channel.id];\n\t\t\tlet object3D = getNode( node.id );\n\r\n\t\t\tlet transform = node.transforms[channel.sid];\n\t\t\tlet defaultMatrix = node.matrix.clone().transpose();\n\r\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\r\n\t\t\tlet data = {};\n\r\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\r\n\t\t\tswitch ( transform ) {\n\r\n\t\t\t\tcase 'matrix':\n\r\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\r\n\t\t\t\t\t\ttime = inputSource.array[i];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\r\n\t\t\t\t\t\tif ( data[time] === undefined ) data[time] = {};\n\r\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\r\n\t\t\t\t\t\t\tlet value = outputSource.array[stride];\n\t\t\t\t\t\t\tlet index = channel.indices[0] + 4 * channel.indices[1];\n\r\n\t\t\t\t\t\t\tdata[time][index] = value;\n\r\n\t\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\r\n\t\t\t\t\t\t\t\tdata[time][j] = outputSource.array[stride + j];\n\r\n\t\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\r\n\t\t\t}\n\r\n\t\t\tlet keyframes = prepareAnimationData( data, defaultMatrix );\n\r\n\t\t\tlet animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes,\r\n\t\t\t};\n\r\n\t\t\treturn animation;\n\r\n\t\t}\n\r\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\r\n\t\t\tlet keyframes = [];\n\r\n\t\t\t// transfer data into a sortable array\n\r\n\t\t\tfor ( let time in data ) {\n\r\n\t\t\t\tkeyframes.push( {time: parseFloat( time ), value: data[time]} );\n\r\n\t\t\t}\n\r\n\t\t\t// ensure keyframes are sorted by time\n\r\n\t\t\tkeyframes.sort( ascending );\n\r\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\r\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\r\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[i] );\n\r\n\t\t\t}\n\r\n\t\t\treturn keyframes;\n\r\n\t\t\t// array sort function\n\r\n\t\t\tfunction ascending( a, b ) {\n\r\n\t\t\t\treturn a.time - b.time;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tlet position = new THREE.Vector3();\n\t\tlet scale = new THREE.Vector3();\n\t\tlet quaternion = new THREE.Quaternion();\n\r\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\r\n\t\t\tlet keyframes = animation.keyframes;\n\t\t\tlet name = animation.name;\n\r\n\t\t\tlet times = [];\n\t\t\tlet positionData = [];\n\t\t\tlet quaternionData = [];\n\t\t\tlet scaleData = [];\n\r\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet keyframe = keyframes[i];\n\r\n\t\t\t\tlet time = keyframe.time;\n\t\t\t\tlet value = keyframe.value;\n\r\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\r\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\r\n\t\t\t}\n\r\n\t\t\tif ( positionData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new THREE.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\r\n\t\t\treturn tracks;\n\r\n\t\t}\n\r\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\r\n\t\t\tlet keyframe;\n\r\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\r\n\t\t\t// check, if values of a property are missing in our keyframes\n\r\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\r\n\t\t\t\tkeyframe = keyframes[i];\n\r\n\t\t\t\tif ( keyframe.value[property] === undefined ) {\n\r\n\t\t\t\t\tkeyframe.value[property] = null; // mark as missing\n\r\n\t\t\t\t} else {\n\r\n\t\t\t\t\tempty = false;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tif ( empty === true ) {\n\r\n\t\t\t\t// no values at all, so we set a default value\n\r\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\r\n\t\t\t\t\tkeyframe = keyframes[i];\n\r\n\t\t\t\t\tkeyframe.value[property] = defaultValue;\n\r\n\t\t\t\t}\n\r\n\t\t\t} else {\n\r\n\t\t\t\t// filling gaps\n\r\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\r\n\t\t\tlet prev, next;\n\r\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet keyframe = keyframes[i];\n\r\n\t\t\t\tif ( keyframe.value[property] === null ) {\n\r\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\r\n\t\t\t\t\tif ( prev === null ) {\n\r\n\t\t\t\t\t\tkeyframe.value[property] = next.value[property];\n\t\t\t\t\t\tcontinue;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tif ( next === null ) {\n\r\n\t\t\t\t\t\tkeyframe.value[property] = prev.value[property];\n\t\t\t\t\t\tcontinue;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction getPrev( keyframes, i, property ) {\n\r\n\t\t\twhile ( i >= 0 ) {\n\r\n\t\t\t\tlet keyframe = keyframes[i];\n\r\n\t\t\t\tif ( keyframe.value[property] !== null ) return keyframe;\n\r\n\t\t\t\ti --;\n\r\n\t\t\t}\n\r\n\t\t\treturn null;\n\r\n\t\t}\n\r\n\t\tfunction getNext( keyframes, i, property ) {\n\r\n\t\t\twhile ( i < keyframes.length ) {\n\r\n\t\t\t\tlet keyframe = keyframes[i];\n\r\n\t\t\t\tif ( keyframe.value[property] !== null ) return keyframe;\n\r\n\t\t\t\ti ++;\n\r\n\t\t\t}\n\r\n\t\t\treturn null;\n\r\n\t\t}\n\r\n\t\tfunction interpolate( key, prev, next, property ) {\n\r\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\r\n\t\t\t\tkey.value[property] = prev.value[property];\n\t\t\t\treturn;\n\r\n\t\t\t}\n\r\n\t\t\tkey.value[property] = ( ( key.time - prev.time ) * ( next.value[property] - prev.value[property] ) / ( next.time - prev.time ) ) + prev.value[property];\n\r\n\t\t}\n\r\n\t\t// animation clips\n\r\n\t\tfunction parseAnimationClip( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: [],\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.clips[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction buildAnimationClip( data ) {\n\r\n\t\t\tlet tracks = [];\n\r\n\t\t\tlet name = data.name;\n\t\t\tlet duration = ( data.end - data.start ) || - 1;\n\t\t\tlet animations = data.animations;\n\r\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\r\n\t\t\t\tlet animationTracks = getAnimation( animations[i] );\n\r\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\r\n\t\t\t\t\ttracks.push( animationTracks[j] );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn new THREE.AnimationClip( name, duration, tracks );\n\r\n\t\t}\n\r\n\t\tfunction getAnimationClip( id ) {\n\r\n\t\t\treturn getBuild( library.clips[id], buildAnimationClip );\n\r\n\t\t}\n\r\n\t\t// controller\n\r\n\t\tfunction parseController( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.controllers[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseSkin( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tsources: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[id] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseJoints( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tinputs: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[semantic] = id;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseVertexWeights( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tinputs: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[semantic] = {id: id, offset: offset};\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildController( data ) {\n\r\n\t\t\tlet build = {\n\t\t\t\tid: data.id,\r\n\t\t\t};\n\r\n\t\t\tlet geometry = library.geometries[build.id];\n\r\n\t\t\tif ( data.skin !== undefined ) {\n\r\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\r\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\r\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\r\n\t\t\t}\n\r\n\t\t\treturn build;\n\r\n\t\t}\n\r\n\t\tfunction buildSkin( data ) {\n\r\n\t\t\tlet BONE_LIMIT = 4;\n\r\n\t\t\tlet build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT,\r\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT,\r\n\t\t\t\t},\r\n\t\t\t};\n\r\n\t\t\tlet sources = data.sources;\n\t\t\tlet vertexWeights = data.vertexWeights;\n\r\n\t\t\tlet vcount = vertexWeights.vcount;\n\t\t\tlet v = vertexWeights.v;\n\t\t\tlet jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tlet weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\r\n\t\t\tlet jointSource = data.sources[data.joints.inputs.JOINT];\n\t\t\tlet inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n\r\n\t\t\tlet weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n\t\t\tlet stride = 0;\n\r\n\t\t\tlet i, j, l;\n\r\n\t\t\t// procces skin data for each vertex\n\r\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\t\t\t\tlet vertexSkinData = [];\n\r\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\r\n\t\t\t\t\tlet skinIndex = v[stride + jointOffset];\n\t\t\t\t\tlet weightId = v[stride + weightOffset];\n\t\t\t\t\tlet skinWeight = weights[weightId];\n\r\n\t\t\t\t\tvertexSkinData.push( {index: skinIndex, weight: skinWeight} );\n\r\n\t\t\t\t\tstride += 2;\n\r\n\t\t\t\t}\n\r\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\r\n\t\t\t\tvertexSkinData.sort( descending );\n\r\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\r\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\r\n\t\t\t\t\tlet d = vertexSkinData[j];\n\r\n\t\t\t\t\tif ( d !== undefined ) {\n\r\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// setup bind matrix\n\r\n\t\t\tbuild.bindMatrix = new THREE.Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\r\n\t\t\t// process bones and inverse bind matrix data\n\r\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet name = jointSource.array[i];\n\t\t\t\tlet boneInverse = new THREE.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\r\n\t\t\t\tbuild.joints.push( {name: name, boneInverse: boneInverse} );\n\r\n\t\t\t}\n\r\n\t\t\treturn build;\n\r\n\t\t\t// array sort function\n\r\n\t\t\tfunction descending( a, b ) {\n\r\n\t\t\t\treturn b.weight - a.weight;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction getController( id ) {\n\r\n\t\t\treturn getBuild( library.controllers[id], buildController );\n\r\n\t\t}\n\r\n\t\t// image\n\r\n\t\tfunction parseImage( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[0].textContent,\r\n\t\t\t};\n\r\n\t\t\tlibrary.images[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction buildImage( data ) {\n\r\n\t\t\tif ( data.build !== undefined ) return data.build;\n\r\n\t\t\treturn data.init_from;\n\r\n\t\t}\n\r\n\t\tfunction getImage( id ) {\n\r\n\t\t\treturn getBuild( library.images[id], buildImage );\n\r\n\t\t}\n\r\n\t\t// effect\n\r\n\t\tfunction parseEffect( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.effects[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectNewparam( xml, data ) {\n\r\n\t\t\tlet sid = xml.getAttribute( 'sid' );\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[sid] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[sid] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction parseEffectSurface( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectSampler( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectTechnique( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectParameters( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[child.nodeName] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[child.nodeName] = {\n\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\tdata: parseEffectParameter( child ),\r\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectParameter( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[child.nodeName] = {id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child )};\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectParameterTexture( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\ttechnique: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[child.nodeName] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\r\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\r\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\r\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = 1;\n\r\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\r\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = 0;\n\r\n\t\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = parseInt( child.textContent );\n\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction parseEffectExtra( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[child.nodeName] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildEffect( data ) {\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction getEffect( id ) {\n\r\n\t\t\treturn getBuild( library.effects[id], buildEffect );\n\r\n\t\t}\n\r\n\t\t// material\n\r\n\t\tfunction parseMaterial( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.materials[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction buildMaterial( data ) {\n\r\n\t\t\tlet effect = getEffect( data.url );\n\t\t\tlet technique = effect.profile.technique;\n\t\t\tlet extra = effect.profile.extra;\n\r\n\t\t\tlet material;\n\r\n\t\t\tswitch ( technique.type ) {\n\r\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\r\n\t\t\t}\n\r\n\t\t\tmaterial.name = data.name;\n\r\n\t\t\tfunction getTexture( textureObject ) {\n\r\n\t\t\t\tlet sampler = effect.profile.samplers[textureObject.id];\n\t\t\t\tlet image;\n\r\n\t\t\t\t// get image\n\r\n\t\t\t\tif ( sampler !== undefined ) {\n\r\n\t\t\t\t\tlet surface = effect.profile.surfaces[sampler.source];\n\t\t\t\t\timage = getImage( surface.init_from );\n\r\n\t\t\t\t} else {\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\r\n\t\t\t\t}\n\r\n\t\t\t\t// create texture if image is avaiable\n\r\n\t\t\t\tif ( image !== undefined ) {\n\r\n\t\t\t\t\tlet texture = textureLoader.load( image );\n\r\n\t\t\t\t\tlet extra = textureObject.extra;\n\r\n\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\r\n\t\t\t\t\t\tlet technique = extra.technique;\n\r\n\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\r\n\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\treturn texture;\n\r\n\t\t\t\t} else {\n\r\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to load texture with ID:', textureObject.id );\n\r\n\t\t\t\t\treturn null;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlet parameters = technique.parameters;\n\r\n\t\t\tfor ( let key in parameters ) {\n\r\n\t\t\t\tlet parameter = parameters[key];\n\r\n\t\t\t\tswitch ( key ) {\n\r\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess )\n\t\t\t\t\t\t\t{material.shininess = parameter.float;}\r\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive )\n\t\t\t\t\t\t\t{material.emissive.fromArray( parameter.color );}\r\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t//\n\r\n\t\t\tlet transparent = parameters.transparent;\n\t\t\tlet transparency = parameters.transparency;\n\r\n\t\t\t// <transparency> does not exist but <transparent>\n\r\n\t\t\tif ( transparency === undefined && transparent ) {\n\r\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1,\r\n\t\t\t\t};\n\r\n\t\t\t}\n\r\n\t\t\t// <transparent> does not exist but <transparency>\n\r\n\t\t\tif ( transparent === undefined && transparency ) {\n\r\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [1, 1, 1, 1],\r\n\t\t\t\t\t}};\n\r\n\t\t\t}\n\r\n\t\t\tif ( transparent && transparency ) {\n\r\n\t\t\t\t// handle case if a texture exists but no color\n\r\n\t\t\t\tif ( transparent.data.texture ) {\n\r\n\t\t\t\t\tmaterial.alphaMap = getTexture( transparent.data.texture );\n\t\t\t\t\tmaterial.transparent = true;\n\r\n\t\t\t\t} else {\n\r\n\t\t\t\t\tlet color = transparent.data.color;\n\r\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\r\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[3] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[0] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[3] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[0] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t//\n\r\n\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\r\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\r\n\t\t\t}\n\r\n\t\t\treturn material;\n\r\n\t\t}\n\r\n\t\tfunction getMaterial( id ) {\n\r\n\t\t\treturn getBuild( library.materials[id], buildMaterial );\n\r\n\t\t}\n\r\n\t\t// camera\n\r\n\t\tfunction parseCamera( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.cameras[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseCameraOptics( xml ) {\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn {};\n\r\n\t\t}\n\r\n\t\tfunction parseCameraTechnique( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\r\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\r\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseCameraParameters( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildCamera( data ) {\n\r\n\t\t\tlet camera;\n\r\n\t\t\tswitch ( data.optics.technique ) {\n\r\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\r\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\r\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\r\n\t\t\t\t\tcamera = new THREE.OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new THREE.PerspectiveCamera();\n\t\t\t\t\tbreak;\n\r\n\t\t\t}\n\r\n\t\t\tcamera.name = data.name;\n\r\n\t\t\treturn camera;\n\r\n\t\t}\n\r\n\t\tfunction getCamera( id ) {\n\r\n\t\t\tlet data = library.cameras[id];\n\r\n\t\t\tif ( data !== undefined ) {\n\r\n\t\t\t\treturn getBuild( data, buildCamera );\n\r\n\t\t\t}\n\r\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\r\n\t\t\treturn null;\n\r\n\t\t}\n\r\n\t\t// light\n\r\n\t\tfunction parseLight( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.lights[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseLightTechnique( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\r\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseLightParameters( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new THREE.Color().fromArray( array );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildLight( data ) {\n\r\n\t\t\tlet light;\n\r\n\t\t\tswitch ( data.technique ) {\n\r\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new THREE.AmbientLight();\n\t\t\t\t\tbreak;\n\r\n\t\t\t}\n\r\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\r\n\t\t\treturn light;\n\r\n\t\t}\n\r\n\t\tfunction getLight( id ) {\n\r\n\t\t\tlet data = library.lights[id];\n\r\n\t\t\tif ( data !== undefined ) {\n\r\n\t\t\t\treturn getBuild( data, buildLight );\n\r\n\t\t\t}\n\r\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\r\n\t\t\treturn null;\n\r\n\t\t}\n\r\n\t\t// geometry\n\r\n\t\tfunction parseGeometry( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: [],\r\n\t\t\t};\n\r\n\t\t\tlet mesh = getElementsByTagName( xml, 'mesh' )[0];\n\r\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\r\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = mesh.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tlet id = child.getAttribute( 'id' );\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[id] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.geometries[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseSource( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3,\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[0];\n\r\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\r\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\r\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseGeometryVertices( xml ) {\n\r\n\t\t\tlet data = {};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tdata[child.getAttribute( 'semantic' )] = parseId( child.getAttribute( 'source' ) );\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseGeometryPrimitive( xml ) {\n\r\n\t\t\tlet primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tprimitive.inputs[semantic] = {id: id, offset: offset};\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn primitive;\n\r\n\t\t}\n\r\n\t\tfunction groupPrimitives( primitives ) {\n\r\n\t\t\tlet build = {};\n\r\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\r\n\t\t\t\tlet primitive = primitives[i];\n\r\n\t\t\t\tif ( build[primitive.type] === undefined ) build[primitive.type] = [];\n\r\n\t\t\t\tbuild[primitive.type].push( primitive );\n\r\n\t\t\t}\n\r\n\t\t\treturn build;\n\r\n\t\t}\n\r\n\t\tfunction buildGeometry( data ) {\n\r\n\t\t\tlet build = {};\n\r\n\t\t\tlet sources = data.sources;\n\t\t\tlet vertices = data.vertices;\n\t\t\tlet primitives = data.primitives;\n\r\n\t\t\tif ( primitives.length === 0 ) return {};\n\r\n\t\t\t// our goal is to create one buffer geoemtry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\r\n\t\t\tlet groupedPrimitives = groupPrimitives( primitives );\n\r\n\t\t\tfor ( let type in groupedPrimitives ) {\n\r\n\t\t\t\t// second, we create for each type of primitives (polylist,triangles or lines) a buffer geometry\n\r\n\t\t\t\tbuild[type] = buildGeometryType( groupedPrimitives[type], sources, vertices );\n\r\n\t\t\t}\n\r\n\t\t\treturn build;\n\r\n\t\t}\n\r\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\r\n\t\t\tlet build = {};\n\r\n\t\t\tlet position = {array: [], stride: 0};\n\t\t\tlet normal = {array: [], stride: 0};\n\t\t\tlet uv = {array: [], stride: 0};\n\t\t\tlet color = {array: [], stride: 0};\n\r\n\t\t\tlet skinIndex = {array: [], stride: 4};\n\t\t\tlet skinWeight = {array: [], stride: 4};\n\r\n\t\t\tlet geometry = new THREE.BufferGeometry();\n\r\n\t\t\tlet materialKeys = [];\n\r\n\t\t\tlet start = 0, count = 0;\n\r\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\r\n\t\t\t\tlet primitive = primitives[p];\n\t\t\t\tlet inputs = primitive.inputs;\n\t\t\t\tlet triangleCount = 1;\n\r\n\t\t\t\tif ( primitive.vcount && primitive.vcount[0] === 4 ) {\n\r\n\t\t\t\t\ttriangleCount = 2; // one quad -> two triangles\n\r\n\t\t\t\t}\n\r\n\t\t\t\t// groups\n\r\n\t\t\t\tif ( primitive.type === 'lines' || primitive.type === 'linestrips' ) {\n\r\n\t\t\t\t\tcount = primitive.count * 2;\n\r\n\t\t\t\t} else {\n\r\n\t\t\t\t\tcount = primitive.count * 3 * triangleCount;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\r\n\t\t\t\t// material\n\r\n\t\t\t\tif ( primitive.material ) {\n\r\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\r\n\t\t\t\t}\n\r\n\t\t\t\t// geometry data\n\r\n\t\t\t\tfor ( let name in inputs ) {\n\r\n\t\t\t\t\tlet input = inputs[name];\n\r\n\t\t\t\t\tswitch ( name )\t{\n\r\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( let key in vertices ) {\n\r\n\t\t\t\t\t\t\t\tlet id = vertices[key];\n\r\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\r\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[id], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[id].stride;\n\r\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\r\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[id], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[id], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[id], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\r\n\t\t\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[input.id], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[input.id], input.offset, color.array );\n\t\t\t\t\t\t\tcolor.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[input.id], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// build geometry\n\r\n\t\t\tif ( position.array.length > 0 ) geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uv.array, uv.stride ) );\n\r\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.addAttribute( 'skinIndex', new THREE.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\r\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[0].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\r\n\t\t\treturn build;\n\r\n\t\t}\n\r\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\r\n\t\t\tlet indices = primitive.p;\n\t\t\tlet stride = primitive.stride;\n\t\t\tlet vcount = primitive.vcount;\n\r\n\t\t\tfunction pushVector( i ) {\n\r\n\t\t\t\tlet index = indices[i + offset] * sourceStride;\n\t\t\t\tlet length = index + sourceStride;\n\r\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\r\n\t\t\t\t\tarray.push( sourceArray[index] );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlet maxcount = 0;\n\r\n\t\t\tvar sourceArray = source.array;\n\t\t\tvar sourceStride = source.stride;\n\r\n\t\t\tif ( primitive.vcount !== undefined ) {\n\r\n\t\t\t\tlet index = 0;\n\r\n\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\r\n\t\t\t\t\tlet count = vcount[i];\n\r\n\t\t\t\t\tif ( count === 4 ) {\n\r\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\tlet d = index + stride * 3;\n\r\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\r\n\t\t\t\t\t} else if ( count === 3 ) {\n\r\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\r\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\tmaxcount = Math.max( maxcount, count );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tindex += stride * count;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tif ( maxcount > 0 ) {\n\r\n\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: Geometry has faces with more than 4 vertices.' );\n\r\n\t\t\t\t}\n\r\n\t\t\t} else {\n\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\n\r\n\t\t\t\t\tpushVector( i );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction getGeometry( id ) {\n\r\n\t\t\treturn getBuild( library.geometries[id], buildGeometry );\n\r\n\t\t}\n\r\n\t\t// kinematics\n\r\n\t\tfunction parseKinematicsModel( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: [],\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.kinematicsModels[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction buildKinematicsModel( data ) {\n\r\n\t\t\tif ( data.build !== undefined ) return data.build;\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction getKinematicsModel( id ) {\n\r\n\t\t\treturn getBuild( library.kinematicsModels[id], buildKinematicsModel );\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[child.getAttribute( 'sid' )] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsJoint( xml ) {\n\r\n\t\t\tlet data;\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsJointParameter( xml, data ) {\n\r\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new THREE.Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0,\r\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0,\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[0];\n\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[0];\n\r\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\r\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\r\n\t\t\t\tdata.static = true;\n\r\n\t\t\t}\n\r\n\t\t\t// calculate middle position\n\r\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsLink( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: [],\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsAttachment( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: [],\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsTransform( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\ttype: xml.nodeName,\r\n\t\t\t};\n\r\n\t\t\tlet array = parseFloats( xml.textContent );\n\r\n\t\t\tswitch ( data.type ) {\n\r\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new THREE.Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = THREE.Math.degToRad( array[3] );\n\t\t\t\t\tbreak;\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsScene( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tbindJointAxis: [],\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.kinematicsScenes[parseId( xml.getAttribute( 'url' ) )] = data;\n\r\n\t\t}\n\r\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop(),\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[0];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[0];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildKinematicsScene( data ) {\n\r\n\t\t\tif ( data.build !== undefined ) return data.build;\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction getKinematicsScene( id ) {\n\r\n\t\t\treturn getBuild( library.kinematicsScenes[id], buildKinematicsScene );\n\r\n\t\t}\n\r\n\t\tfunction setupKinematics() {\n\r\n\t\t\tlet kinematicsModelId = Object.keys( library.kinematicsModels )[0];\n\t\t\tlet kinematicsSceneId = Object.keys( library.kinematicsScenes )[0];\n\t\t\tlet visualSceneId = Object.keys( library.visualScenes )[0];\n\r\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\r\n\t\t\tlet kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tlet kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tlet visualScene = getVisualScene( visualSceneId );\n\r\n\t\t\tlet bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tlet jointMap = {};\n\r\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet axis = bindJointAxis[i];\n\r\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\r\n\t\t\t\tlet targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\r\n\t\t\t\tif ( targetElement ) {\n\r\n\t\t\t\t\t// get the parent of the transfrom element\n\r\n\t\t\t\t\tlet parentVisualElement = targetElement.parentElement;\n\r\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\r\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\r\n\t\t\t\tlet visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tlet joint = kinematicsModel.joints[jointIndex];\n\r\n\t\t\t\tvisualScene.traverse( function( object ) {\n\r\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\r\n\t\t\t\t\t\tjointMap[jointIndex] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition,\r\n\t\t\t\t\t\t};\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t} );\n\r\n\t\t\t}\n\r\n\t\t\tlet m0 = new THREE.Matrix4();\n\r\n\t\t\tkinematics = {\n\r\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\r\n\t\t\t\tgetJointValue: function( jointIndex ) {\n\r\n\t\t\t\t\tlet jointData = jointMap[jointIndex];\n\r\n\t\t\t\t\tif ( jointData ) {\n\r\n\t\t\t\t\t\treturn jointData.position;\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t},\n\r\n\t\t\t\tsetJointValue: function( jointIndex, value ) {\n\r\n\t\t\t\t\tlet jointData = jointMap[jointIndex];\n\r\n\t\t\t\t\tif ( jointData ) {\n\r\n\t\t\t\t\t\tlet joint = jointData.joint;\n\r\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\r\n\t\t\t\t\t\t} else if ( joint.static ) {\n\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\r\n\t\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\t\tlet object = jointData.object;\n\t\t\t\t\t\t\tlet axis = joint.axis;\n\t\t\t\t\t\t\tlet transforms = jointData.transforms;\n\r\n\t\t\t\t\t\t\tmatrix.identity();\n\r\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\r\n\t\t\t\t\t\t\t\tlet transform = transforms[i];\n\r\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\r\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\r\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, THREE.Math.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\r\n\t\t\t\t\t\t\tjointMap[jointIndex].position = value;\n\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t},\r\n\n\t\t\t};\n\r\n\t\t}\n\r\n\t\tfunction buildTransformList( node ) {\n\r\n\t\t\tlet transforms = [];\n\r\n\t\t\tlet xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix,\r\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\r\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray( array );\n\t\t\t\t\t\tvar angle = THREE.Math.degToRad( array[3] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle,\r\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn transforms;\n\r\n\t\t}\n\r\n\t\t// nodes\n\r\n\t\tfunction prepareNodes( xml ) {\n\r\n\t\t\tlet elements = xml.getElementsByTagName( 'node' );\n\r\n\t\t\t// ensure all node elements have id attributes\n\r\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\r\n\t\t\t\tlet element = elements[i];\n\r\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\r\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tvar matrix = new THREE.Matrix4();\n\t\tlet vector = new THREE.Vector3();\n\r\n\t\tfunction parseNode( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new THREE.Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {},\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[child.getAttribute( 'sid' )] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[child.getAttribute( 'sid' )] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar angle = THREE.Math.degToRad( array[3] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[child.getAttribute( 'sid' )] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[child.getAttribute( 'sid' )] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.nodes[data.id] = data;\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction parseNodeInstance( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: [],\r\n\t\t\t};\n\r\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\r\n\t\t\t\tlet child = xml.childNodes[i];\n\r\n\t\t\t\tswitch ( child.nodeName ) {\n\r\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\n\r\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\r\n\t\t\t\t\t\t\tlet instance = instances[j];\n\t\t\t\t\t\t\tlet symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tlet target = instance.getAttribute( 'target' );\n\r\n\t\t\t\t\t\t\tdata.materials[symbol] = parseId( target );\n\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn data;\n\r\n\t\t}\n\r\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\r\n\t\t\tlet boneData = [];\n\t\t\tlet sortedBoneData = [];\n\r\n\t\t\tlet i, j, data;\n\r\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\r\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\r\n\t\t\t\tlet skeleton = skeletons[i];\n\t\t\t\tlet root = getNode( skeleton );\n\r\n\t\t\t\t// setup bone data for a single bone hierarchy\n\r\n\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\r\n\t\t\t}\n\r\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\r\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\r\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\r\n\t\t\t\t\tdata = boneData[j];\n\r\n\t\t\t\t\tif ( data.bone.name === joints[i].name ) {\n\r\n\t\t\t\t\t\tsortedBoneData[i] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// add unprocessed bone data at the end of the list\n\r\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\r\n\t\t\t\tdata = boneData[i];\n\r\n\t\t\t\tif ( data.processed === false ) {\n\r\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// setup arrays for skeleton creation\n\r\n\t\t\tlet bones = [];\n\t\t\tlet boneInverses = [];\n\r\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\r\n\t\t\t\tdata = sortedBoneData[i];\n\r\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\r\n\t\t\t}\n\r\n\t\t\treturn new THREE.Skeleton( bones, boneInverses );\n\r\n\t\t}\n\r\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\r\n\t\t\t// setup bone data from visual scene\n\r\n\t\t\troot.traverse( function( object ) {\n\r\n\t\t\t\tif ( object.isBone === true ) {\n\r\n\t\t\t\t\tlet boneInverse;\n\r\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\r\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\r\n\t\t\t\t\t\tlet joint = joints[i];\n\r\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\r\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\r\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\r\n\t\t\t\t\t\t boneInverse = new THREE.Matrix4();\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tboneData.push( {bone: object, boneInverse: boneInverse, processed: false} );\n\r\n\t\t\t\t}\n\r\n\t\t\t} );\n\r\n\t\t}\n\r\n\t\tfunction buildNode( data ) {\n\r\n\t\t\tlet objects = [];\n\r\n\t\t\tlet matrix = data.matrix;\n\t\t\tlet nodes = data.nodes;\n\t\t\tlet type = data.type;\n\t\t\tlet instanceCameras = data.instanceCameras;\n\t\t\tlet instanceControllers = data.instanceControllers;\n\t\t\tlet instanceLights = data.instanceLights;\n\t\t\tlet instanceGeometries = data.instanceGeometries;\n\t\t\tlet instanceNodes = data.instanceNodes;\n\r\n\t\t\t// nodes\n\r\n\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tobjects.push( getNode( nodes[i] ) );\n\r\n\t\t\t}\n\r\n\t\t\t// instance cameras\n\r\n\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet instanceCamera = getCamera( instanceCameras[i] );\n\r\n\t\t\t\tif ( instanceCamera !== null ) {\n\r\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// instance controllers\n\r\n\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\r\n\t\t\t\tvar instance = instanceControllers[i];\n\t\t\t\tlet controller = getController( instance.id );\n\t\t\t\tvar geometries = getGeometry( controller.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\r\n\t\t\t\tlet skeletons = instance.skeletons;\n\t\t\t\tlet joints = controller.skin.joints;\n\r\n\t\t\t\tlet skeleton = buildSkeleton( skeletons, joints );\n\r\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\r\n\t\t\t\t\tvar object = newObjects[j];\n\r\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\r\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tobjects.push( object );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// instance lights\n\r\n\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet instanceLight = getLight( instanceLights[i] );\n\r\n\t\t\t\tif ( instanceLight !== null ) {\n\r\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// instance geometries\n\r\n\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\r\n\t\t\t\tvar instance = instanceGeometries[i];\n\r\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\r\n\t\t\t\tvar geometries = getGeometry( instance.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\r\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\r\n\t\t\t\t\tobjects.push( newObjects[j] );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\t// instance nodes\n\r\n\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\r\n\t\t\t\tobjects.push( getNode( instanceNodes[i] ).clone() );\n\r\n\t\t\t}\n\r\n\t\t\tvar object;\n\r\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\r\n\t\t\t\tobject = objects[0];\n\r\n\t\t\t} else {\n\r\n\t\t\t\tobject = ( type === 'JOINT' ) ? new THREE.Bone() : new THREE.Group();\n\r\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\r\n\t\t\t\t\tobject.add( objects[i] );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\r\n\t\t\treturn object;\n\r\n\t\t}\n\r\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\r\n\t\t\tlet materials = [];\n\r\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\r\n\t\t\t\tlet id = instanceMaterials[keys[i]];\n\t\t\t\tmaterials.push( getMaterial( id ) );\n\r\n\t\t\t}\n\r\n\t\t\treturn materials;\n\r\n\t\t}\n\r\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\r\n\t\t\tlet objects = [];\n\r\n\t\t\tfor ( let type in geometries ) {\n\r\n\t\t\t\tlet geometry = geometries[type];\n\r\n\t\t\t\tlet materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\r\n\t\t\t\t// handle case if no materials are defined\n\r\n\t\t\t\tif ( materials.length === 0 ) {\n\r\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\r\n\t\t\t\t\t\tmaterials.push( new THREE.LineBasicMaterial() );\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\tmaterials.push( new THREE.MeshPhongMaterial() );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t}\n\r\n\t\t\t\t// regard skinning\n\r\n\t\t\t\tlet skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\r\n\t\t\t\tif ( skinning ) {\n\r\n\t\t\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\r\n\t\t\t\t\t\tmaterials[i].skinning = true;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t}\n\r\n\t\t\t\t// choose between a single or multi materials (material array)\n\r\n\t\t\t\tlet material = ( materials.length === 1 ) ? materials[0] : materials;\n\r\n\t\t\t\t// now create a specific 3D object\n\r\n\t\t\t\tvar object;\n\r\n\t\t\t\tswitch ( type ) {\n\r\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new THREE.LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new THREE.Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\r\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry.data, material );\n\r\n\t\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry.data, material );\n\r\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tobjects.push( object );\n\r\n\t\t\t}\n\r\n\t\t\treturn objects;\n\r\n\t\t}\n\r\n\t\tfunction getNode( id ) {\n\r\n\t\t\treturn getBuild( library.nodes[id], buildNode );\n\r\n\t\t}\n\r\n\t\t// visual scenes\n\r\n\t\tfunction parseVisualScene( xml ) {\n\r\n\t\t\tlet data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: [],\r\n\t\t\t};\n\r\n\t\t\tprepareNodes( xml );\n\r\n\t\t\tlet elements = getElementsByTagName( xml, 'node' );\n\r\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\r\n\t\t\t\tdata.children.push( parseNode( elements[i] ) );\n\r\n\t\t\t}\n\r\n\t\t\tlibrary.visualScenes[xml.getAttribute( 'id' )] = data;\n\r\n\t\t}\n\r\n\t\tfunction buildVisualScene( data ) {\n\r\n\t\t\tlet group = new THREE.Group();\n\t\t\tgroup.name = data.name;\n\r\n\t\t\tlet children = data.children;\n\r\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\r\n\t\t\t\tlet child = children[i];\n\r\n\t\t\t\tif ( child.id === null ) {\n\r\n\t\t\t\t\tgroup.add( buildNode( child ) );\n\r\n\t\t\t\t} else {\n\r\n\t\t\t\t\t// if there is an ID, let's try to get the finished build (e.g. joints are already build)\n\r\n\t\t\t\t\tgroup.add( getNode( child.id ) );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t\treturn group;\n\r\n\t\t}\n\r\n\t\tfunction getVisualScene( id ) {\n\r\n\t\t\treturn getBuild( library.visualScenes[id], buildVisualScene );\n\r\n\t\t}\n\r\n\t\t// scenes\n\r\n\t\tfunction parseScene( xml ) {\n\r\n\t\t\tlet instance = getElementsByTagName( xml, 'instance_visual_scene' )[0];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\r\n\t\t}\n\r\n\t\tfunction setupAnimations() {\n\r\n\t\t\tlet clips = library.clips;\n\r\n\t\t\tif ( isEmpty( clips ) === true ) {\n\r\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\r\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\r\n\t\t\t\t\tlet tracks = [];\n\r\n\t\t\t\t\tfor ( var id in library.animations ) {\n\r\n\t\t\t\t\t\tlet animationTracks = getAnimation( id );\n\r\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\r\n\t\t\t\t\t\t\ttracks.push( animationTracks[i] );\n\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tanimations.push( new THREE.AnimationClip( 'default', - 1, tracks ) );\n\r\n\t\t\t\t}\n\r\n\t\t\t} else {\n\r\n\t\t\t\tfor ( var id in clips ) {\n\r\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\r\n\t\t\t\t}\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\tconsole.time( 'THREE.ColladaLoader' );\n\r\n\t\tif ( text.length === 0 ) {\n\r\n\t\t\treturn {scene: new THREE.Scene()};\n\r\n\t\t}\n\r\n\t\tconsole.time( 'THREE.ColladaLoader: DOMParser' );\n\r\n\t\tlet xml = new DOMParser().parseFromString( text, 'application/xml' );\n\r\n\t\tconsole.timeEnd( 'THREE.ColladaLoader: DOMParser' );\n\r\n\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[0];\n\r\n\t\t// metadata\n\r\n\t\tlet version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\r\n\t\tlet asset = parseAsset( getElementsByTagName( collada, 'asset' )[0] );\n\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\ttextureLoader.setPath( path ).setCrossOrigin( this.crossOrigin );\n\r\n\t\t//\n\r\n\t\tvar animations = [];\n\t\tvar kinematics = {};\n\t\tvar count = 0;\n\r\n\t\t//\n\r\n\t\tvar library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tkinematicsScenes: {},\r\n\t\t};\n\r\n\t\tconsole.time( 'THREE.ColladaLoader: Parse' );\n\r\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\r\n\t\tconsole.timeEnd( 'THREE.ColladaLoader: Parse' );\n\r\n\t\tconsole.time( 'THREE.ColladaLoader: Build' );\n\r\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\r\n\t\tconsole.timeEnd( 'THREE.ColladaLoader: Build' );\n\r\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\r\n\t\tlet scene = parseScene( getElementsByTagName( collada, 'scene' )[0] );\n\r\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\r\n\t\t\tscene.rotation.x = - Math.PI / 2;\n\r\n\t\t}\n\r\n\t\tscene.scale.multiplyScalar( asset.unit );\n\r\n\t\tconsole.timeEnd( 'THREE.ColladaLoader' );\n\r\n\t\treturn {\n\t\t\tanimations: animations,\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene,\r\n\t\t};\n\r\n\t},\r\n\n};\n","/**\n * @author alteredq / http://alteredqualia.com/\n * @author mr.doob / http://mrdoob.com/\n */\n\r\nvar Detector = {\n\r\n\tcanvas: !! window.CanvasRenderingContext2D,\n\twebgl: ( function() {\n\r\n\t\ttry {\n\r\n\t\t\tlet canvas = document.createElement( 'canvas' ); return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );\n\r\n\t\t} catch ( e ) {\n\r\n\t\t\treturn false;\n\r\n\t\t}\n\r\n\t} )(),\n\tworkers: !! window.Worker,\n\tfileapi: window.File && window.FileReader && window.FileList && window.Blob,\n\r\n\tgetWebGLErrorMessage: function() {\n\r\n\t\tlet element = document.createElement( 'div' );\n\t\telement.id = 'webgl-error-message';\n\t\telement.style.fontFamily = 'monospace';\n\t\telement.style.fontSize = '13px';\n\t\telement.style.fontWeight = 'normal';\n\t\telement.style.textAlign = 'center';\n\t\telement.style.background = '#fff';\n\t\telement.style.color = '#000';\n\t\telement.style.padding = '1.5em';\n\t\telement.style.width = '400px';\n\t\telement.style.margin = '5em auto 0';\n\r\n\t\tif ( ! this.webgl ) {\n\r\n\t\t\telement.innerHTML = window.WebGLRenderingContext ? [\n\t\t\t\t'Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br />',\n\t\t\t\t'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.',\r\n\t\t\t].join( '\\n' ) : [\n\t\t\t\t'Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br/>',\n\t\t\t\t'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.',\r\n\t\t\t].join( '\\n' );\n\r\n\t\t}\n\r\n\t\treturn element;\n\r\n\t},\n\r\n\taddGetWebGLMessage: function( parameters ) {\n\r\n\t\tlet parent, id, element;\n\r\n\t\tparameters = parameters || {};\n\r\n\t\tparent = parameters.parent !== undefined ? parameters.parent : document.body;\n\t\tid = parameters.id !== undefined ? parameters.id : 'oldie';\n\r\n\t\telement = Detector.getWebGLErrorMessage();\n\t\telement.id = id;\n\r\n\t\tparent.appendChild( element );\n\r\n\t},\r\n\n};\n\r\n// browserify support\nif ( typeof module === 'object' ) {\n\r\n\tmodule.exports = Detector;\n\r\n}\n","/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\n\r\nTHREE.OrbitControls = function( object, domElement ) {\n\r\n\tthis.object = object;\n\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\r\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\r\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\r\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\r\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\r\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\r\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = - Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\r\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.25;\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\r\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\r\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\r\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\r\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\r\n\t// The four arrow keys\n\tthis.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};\n\r\n\t// Mouse buttons\n\tthis.mouseButtons = {ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT};\n\r\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\r\n\t//\n\t// public methods\n\t//\n\r\n\tthis.getPolarAngle = function() {\n\r\n\t\treturn spherical.phi;\n\r\n\t};\n\r\n\tthis.getAzimuthalAngle = function() {\n\r\n\t\treturn spherical.theta;\n\r\n\t};\n\r\n\tthis.saveState = function() {\n\r\n\t\tscope.target0.copy( scope.target );\n\t\tscope.position0.copy( scope.object.position );\n\t\tscope.zoom0 = scope.object.zoom;\n\r\n\t};\n\r\n\tthis.reset = function() {\n\r\n\t\tscope.target.copy( scope.target0 );\n\t\tscope.object.position.copy( scope.position0 );\n\t\tscope.object.zoom = scope.zoom0;\n\r\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent( changeEvent );\n\r\n\t\tscope.update();\n\r\n\t\tstate = STATE.NONE;\n\r\n\t};\n\r\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function() {\n\r\n\t\tlet offset = new THREE.Vector3();\n\r\n\t\t// so camera.up is the orbit axis\n\t\tlet quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\tlet quatInverse = quat.clone().inverse();\n\r\n\t\tlet lastPosition = new THREE.Vector3();\n\t\tlet lastQuaternion = new THREE.Quaternion();\n\r\n\t\treturn function update() {\n\r\n\t\t\tlet position = scope.object.position;\n\r\n\t\t\toffset.copy( position ).sub( scope.target );\n\r\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion( quat );\n\r\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3( offset );\n\r\n\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\r\n\t\t\t\trotateLeft( getAutoRotationAngle() );\n\r\n\t\t\t}\n\r\n\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\tspherical.phi += sphericalDelta.phi;\n\r\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\r\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\r\n\t\t\tspherical.makeSafe();\n\r\n\n\t\t\tspherical.radius *= scale;\n\r\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\r\n\t\t\t// move target to panned location\n\t\t\tscope.target.add( panOffset );\n\r\n\t\t\toffset.setFromSpherical( spherical );\n\r\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion( quatInverse );\n\r\n\t\t\tposition.copy( scope.target ).add( offset );\n\r\n\t\t\tscope.object.lookAt( scope.target );\n\r\n\t\t\tif ( scope.enableDamping === true ) {\n\r\n\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\r\n\t\t\t} else {\n\r\n\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\r\n\t\t\t}\n\r\n\t\t\tscale = 1;\n\t\t\tpanOffset.set( 0, 0, 0 );\n\r\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\r\n\t\t\tif ( zoomChanged ||\n\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\r\n\t\t\t\tscope.dispatchEvent( changeEvent );\n\r\n\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\tzoomChanged = false;\n\r\n\t\t\t\treturn true;\n\r\n\t\t\t}\n\r\n\t\t\treturn false;\n\r\n\t\t};\n\r\n\t}();\n\r\n\tthis.dispose = function() {\n\r\n\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\r\n\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\r\n\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\r\n\t\t// scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\r\n\t};\n\r\n\t//\n\t// internals\n\t//\n\r\n\tvar scope = this;\n\r\n\tvar changeEvent = {type: 'change'};\n\tlet startEvent = {type: 'start'};\n\tlet endEvent = {type: 'end'};\n\r\n\tvar STATE = {NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5};\n\r\n\tvar state = STATE.NONE;\n\r\n\tvar EPS = 0.000001;\n\r\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\r\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\r\n\tlet rotateStart = new THREE.Vector2();\n\tlet rotateEnd = new THREE.Vector2();\n\tlet rotateDelta = new THREE.Vector2();\n\r\n\tlet panStart = new THREE.Vector2();\n\tlet panEnd = new THREE.Vector2();\n\tlet panDelta = new THREE.Vector2();\n\r\n\tlet dollyStart = new THREE.Vector2();\n\tlet dollyEnd = new THREE.Vector2();\n\tlet dollyDelta = new THREE.Vector2();\n\r\n\tfunction getAutoRotationAngle() {\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\r\n\t}\n\r\n\tfunction getZoomScale() {\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\r\n\t}\n\r\n\tfunction rotateLeft( angle ) {\n\r\n\t\tsphericalDelta.theta -= angle;\n\r\n\t}\n\r\n\tfunction rotateUp( angle ) {\n\r\n\t\tsphericalDelta.phi -= angle;\n\r\n\t}\n\r\n\tlet panLeft = function() {\n\r\n\t\tlet v = new THREE.Vector3();\n\r\n\t\treturn function panLeft( distance, objectMatrix ) {\n\r\n\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\tv.multiplyScalar( - distance );\n\r\n\t\t\tpanOffset.add( v );\n\r\n\t\t};\n\r\n\t}();\n\r\n\tlet panUp = function() {\n\r\n\t\tlet v = new THREE.Vector3();\n\r\n\t\treturn function panUp( distance, objectMatrix ) {\n\r\n\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\tv.multiplyScalar( distance );\n\r\n\t\t\tpanOffset.add( v );\n\r\n\t\t};\n\r\n\t}();\n\r\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tlet pan = function() {\n\r\n\t\tlet offset = new THREE.Vector3();\n\r\n\t\treturn function pan( deltaX, deltaY ) {\n\r\n\t\t\tlet element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\r\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\r\n\t\t\t\t// perspective\n\t\t\t\tlet position = scope.object.position;\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\tlet targetDistance = offset.length();\n\r\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\r\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\r\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\r\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\r\n\t\t\t} else {\n\r\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\tscope.enablePan = false;\n\r\n\t\t\t}\n\r\n\t\t};\n\r\n\t}();\n\r\n\tfunction dollyIn( dollyScale ) {\n\r\n\t\tif ( scope.object.isPerspectiveCamera ) {\n\r\n\t\t\tscale /= dollyScale;\n\r\n\t\t} else if ( scope.object.isOrthographicCamera ) {\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\r\n\t\t} else {\n\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tscope.enableZoom = false;\n\r\n\t\t}\n\r\n\t}\n\r\n\tfunction dollyOut( dollyScale ) {\n\r\n\t\tif ( scope.object.isPerspectiveCamera ) {\n\r\n\t\t\tscale *= dollyScale;\n\r\n\t\t} else if ( scope.object.isOrthographicCamera ) {\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\r\n\t\t} else {\n\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tscope.enableZoom = false;\n\r\n\t\t}\n\r\n\t}\n\r\n\t//\n\t// event callbacks - update the object state\n\t//\n\r\n\tfunction handleMouseDownRotate( event ) {\n\r\n\t\t// console.log( 'handleMouseDownRotate' );\n\r\n\t\trotateStart.set( event.clientX, event.clientY );\n\r\n\t}\n\r\n\tfunction handleMouseDownDolly( event ) {\n\r\n\t\t// console.log( 'handleMouseDownDolly' );\n\r\n\t\tdollyStart.set( event.clientX, event.clientY );\n\r\n\t}\n\r\n\tfunction handleMouseDownPan( event ) {\n\r\n\t\t// console.log( 'handleMouseDownPan' );\n\r\n\t\tpanStart.set( event.clientX, event.clientY );\n\r\n\t}\n\r\n\tfunction handleMouseMoveRotate( event ) {\n\r\n\t\t// console.log( 'handleMouseMoveRotate' );\n\r\n\t\trotateEnd.set( event.clientX, event.clientY );\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\r\n\t\tlet element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\r\n\t\t// rotating across whole screen goes 360 degrees around\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\r\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\r\n\t\trotateStart.copy( rotateEnd );\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleMouseMoveDolly( event ) {\n\r\n\t\t// console.log( 'handleMouseMoveDolly' );\n\r\n\t\tdollyEnd.set( event.clientX, event.clientY );\n\r\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\r\n\t\tif ( dollyDelta.y > 0 ) {\n\r\n\t\t\tdollyIn( getZoomScale() );\n\r\n\t\t} else if ( dollyDelta.y < 0 ) {\n\r\n\t\t\tdollyOut( getZoomScale() );\n\r\n\t\t}\n\r\n\t\tdollyStart.copy( dollyEnd );\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleMouseMovePan( event ) {\n\r\n\t\t// console.log( 'handleMouseMovePan' );\n\r\n\t\tpanEnd.set( event.clientX, event.clientY );\n\r\n\t\tpanDelta.subVectors( panEnd, panStart );\n\r\n\t\tpan( panDelta.x, panDelta.y );\n\r\n\t\tpanStart.copy( panEnd );\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleMouseUp( event ) {\n\r\n\t\t// console.log( 'handleMouseUp' );\n\r\n\t}\n\r\n\tfunction handleMouseWheel( event ) {\n\r\n\t\t// console.log( 'handleMouseWheel' );\n\r\n\t\tif ( event.deltaY < 0 ) {\n\r\n\t\t\tdollyOut( getZoomScale() );\n\r\n\t\t} else if ( event.deltaY > 0 ) {\n\r\n\t\t\tdollyIn( getZoomScale() );\n\r\n\t\t}\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleKeyDown( event ) {\n\r\n\t\t// console.log( 'handleKeyDown' );\n\r\n\t\tswitch ( event.keyCode ) {\n\r\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\r\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\r\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\r\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\r\n\t\t}\n\r\n\t}\n\r\n\tfunction handleTouchStartRotate( event ) {\n\r\n\t\t// console.log( 'handleTouchStartRotate' );\n\r\n\t\trotateStart.set( event.touches[0].pageX, event.touches[0].pageY );\n\r\n\t}\n\r\n\tfunction handleTouchStartDolly( event ) {\n\r\n\t\t// console.log( 'handleTouchStartDolly' );\n\r\n\t\tlet dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tlet dy = event.touches[0].pageY - event.touches[1].pageY;\n\r\n\t\tlet distance = Math.sqrt( dx * dx + dy * dy );\n\r\n\t\tdollyStart.set( 0, distance );\n\r\n\t}\n\r\n\tfunction handleTouchStartPan( event ) {\n\r\n\t\t// console.log( 'handleTouchStartPan' );\n\r\n\t\tpanStart.set( event.touches[0].pageX, event.touches[0].pageY );\n\r\n\t}\n\r\n\tfunction handleTouchMoveRotate( event ) {\n\r\n\t\t// console.log( 'handleTouchMoveRotate' );\n\r\n\t\trotateEnd.set( event.touches[0].pageX, event.touches[0].pageY );\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\r\n\t\tlet element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\r\n\t\t// rotating across whole screen goes 360 degrees around\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\r\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\r\n\t\trotateStart.copy( rotateEnd );\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleTouchMoveDolly( event ) {\n\r\n\t\t// console.log( 'handleTouchMoveDolly' );\n\r\n\t\tlet dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tlet dy = event.touches[0].pageY - event.touches[1].pageY;\n\r\n\t\tlet distance = Math.sqrt( dx * dx + dy * dy );\n\r\n\t\tdollyEnd.set( 0, distance );\n\r\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\r\n\t\tif ( dollyDelta.y > 0 ) {\n\r\n\t\t\tdollyOut( getZoomScale() );\n\r\n\t\t} else if ( dollyDelta.y < 0 ) {\n\r\n\t\t\tdollyIn( getZoomScale() );\n\r\n\t\t}\n\r\n\t\tdollyStart.copy( dollyEnd );\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleTouchMovePan( event ) {\n\r\n\t\t// console.log( 'handleTouchMovePan' );\n\r\n\t\tpanEnd.set( event.touches[0].pageX, event.touches[0].pageY );\n\r\n\t\tpanDelta.subVectors( panEnd, panStart );\n\r\n\t\tpan( panDelta.x, panDelta.y );\n\r\n\t\tpanStart.copy( panEnd );\n\r\n\t\tscope.update();\n\r\n\t}\n\r\n\tfunction handleTouchEnd( event ) {\n\r\n\t\t// console.log( 'handleTouchEnd' );\n\r\n\t}\n\r\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\r\n\tfunction onMouseDown( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\tevent.preventDefault();\n\r\n\t\tswitch ( event.button ) {\n\r\n\t\t\tcase scope.mouseButtons.ORBIT:\n\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\r\n\t\t\t\thandleMouseDownRotate( event );\n\r\n\t\t\t\tstate = STATE.ROTATE;\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase scope.mouseButtons.ZOOM:\n\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\r\n\t\t\t\thandleMouseDownDolly( event );\n\r\n\t\t\t\tstate = STATE.DOLLY;\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase scope.mouseButtons.PAN:\n\r\n\t\t\t\tif ( scope.enablePan === false ) return;\n\r\n\t\t\t\thandleMouseDownPan( event );\n\r\n\t\t\t\tstate = STATE.PAN;\n\r\n\t\t\t\tbreak;\n\r\n\t\t}\n\r\n\t\tif ( state !== STATE.NONE ) {\n\r\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\r\n\t\t\tscope.dispatchEvent( startEvent );\n\r\n\t\t}\n\r\n\t}\n\r\n\tfunction onMouseMove( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\tevent.preventDefault();\n\r\n\t\tswitch ( state ) {\n\r\n\t\t\tcase STATE.ROTATE:\n\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\r\n\t\t\t\thandleMouseMoveRotate( event );\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase STATE.DOLLY:\n\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\r\n\t\t\t\thandleMouseMoveDolly( event );\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase STATE.PAN:\n\r\n\t\t\t\tif ( scope.enablePan === false ) return;\n\r\n\t\t\t\thandleMouseMovePan( event );\n\r\n\t\t\t\tbreak;\n\r\n\t\t}\n\r\n\t}\n\r\n\tfunction onMouseUp( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\thandleMouseUp( event );\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\r\n\t\tscope.dispatchEvent( endEvent );\n\r\n\t\tstate = STATE.NONE;\n\r\n\t}\n\r\n\tfunction onMouseWheel( event ) {\n\r\n\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\r\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\r\n\t\tscope.dispatchEvent( startEvent );\n\r\n\t\thandleMouseWheel( event );\n\r\n\t\tscope.dispatchEvent( endEvent );\n\r\n\t}\n\r\n\tfunction onKeyDown( event ) {\n\r\n\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\r\n\t\thandleKeyDown( event );\n\r\n\t}\n\r\n\tfunction onTouchStart( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\tswitch ( event.touches.length ) {\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\r\n\t\t\t\thandleTouchStartRotate( event );\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\r\n\t\t\t\thandleTouchStartDolly( event );\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase 3: // three-fingered touch: pan\n\r\n\t\t\t\tif ( scope.enablePan === false ) return;\n\r\n\t\t\t\thandleTouchStartPan( event );\n\r\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tdefault:\n\r\n\t\t\t\tstate = STATE.NONE;\n\r\n\t\t}\n\r\n\t\tif ( state !== STATE.NONE ) {\n\r\n\t\t\tscope.dispatchEvent( startEvent );\n\r\n\t\t}\n\r\n\t}\n\r\n\tfunction onTouchMove( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\r\n\t\tswitch ( event.touches.length ) {\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\n\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\r\n\t\t\t\thandleTouchMoveRotate( event );\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase 2: // two-fingered touch: dolly\n\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\r\n\t\t\t\thandleTouchMoveDolly( event );\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tcase 3: // three-fingered touch: pan\n\r\n\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\r\n\t\t\t\thandleTouchMovePan( event );\n\r\n\t\t\t\tbreak;\n\r\n\t\t\tdefault:\n\r\n\t\t\t\tstate = STATE.NONE;\n\r\n\t\t}\n\r\n\t}\n\r\n\tfunction onTouchEnd( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\thandleTouchEnd( event );\n\r\n\t\tscope.dispatchEvent( endEvent );\n\r\n\t\tstate = STATE.NONE;\n\r\n\t}\n\r\n\tfunction onContextMenu( event ) {\n\r\n\t\tif ( scope.enabled === false ) return;\n\r\n\t\tevent.preventDefault();\n\r\n\t}\n\r\n\t//\n\r\n\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\r\n\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\r\n\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\r\n\twindow.addEventListener( 'keydown', onKeyDown, false );\n\r\n\t// force an update at start\n\r\n\tthis.update();\n\r\n};\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\r\nObject.defineProperties( THREE.OrbitControls.prototype, {\n\r\n\tcenter: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\treturn this.target;\n\r\n\t\t},\r\n\n\t},\n\r\n\t// backward compatibility\n\r\n\tnoZoom: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\treturn ! this.enableZoom;\n\r\n\t\t},\n\r\n\t\tset: function( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\tthis.enableZoom = ! value;\n\r\n\t\t},\r\n\n\t},\n\r\n\tnoRotate: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\treturn ! this.enableRotate;\n\r\n\t\t},\n\r\n\t\tset: function( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\tthis.enableRotate = ! value;\n\r\n\t\t},\r\n\n\t},\n\r\n\tnoPan: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\treturn ! this.enablePan;\n\r\n\t\t},\n\r\n\t\tset: function( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\tthis.enablePan = ! value;\n\r\n\t\t},\r\n\n\t},\n\r\n\tnoKeys: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\treturn ! this.enableKeys;\n\r\n\t\t},\n\r\n\t\tset: function( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\tthis.enableKeys = ! value;\n\r\n\t\t},\r\n\n\t},\n\r\n\tstaticMoving: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\treturn ! this.enableDamping;\n\r\n\t\t},\n\r\n\t\tset: function( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\tthis.enableDamping = ! value;\n\r\n\t\t},\r\n\n\t},\n\r\n\tdynamicDampingFactor: {\n\r\n\t\tget: function() {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\treturn this.dampingFactor;\n\r\n\t\t},\n\r\n\t\tset: function( value ) {\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\tthis.dampingFactor = value;\n\r\n\t\t},\r\n\n\t},\r\n\n} );\n","// stats.js - http://github.com/mrdoob/stats.js\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);","// window.console.clear();\n\nif ( ! Detector.webgl ) Detector.addGetWebGLMessage();\n\t\t\tlet container, stats, clock;\n\t\t\tlet camera, scene, renderer, logo;\n\t\t\tinit();\n\t\t\tanimate();\n\t\t\tfunction init() {\n\t\t\t\tcontainer = document.getElementById( 'front' );\n\t\t\t\tcontainer.style.height = window.innerHeight + 'px';\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 67.5, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\t\tcamera.position.set( -200, 100, 280 );\n     \n        //\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tclock = new THREE.Clock();\n\t\t\t\t// loading manager\n\t\t\t\tlet loadingManager = new THREE.LoadingManager( function() {\n\t\t\t\t\tscene.add( logo );\n\t\t\t\t} );\n        \n\t\t\t\t// loader\n\t\t\t\tlet loader = new THREE.ColladaLoader( loadingManager );\n\t\t\t\tloader.load( 'https://raw.githubusercontent.com/davegahn/test/master/scripts/F34.dae', function( collada ) {\n\t\t\t\t\tlogo = collada.scene;\n\t\t\t\t} );\n        \n\t\t\t\t// lights\n\t\t\t\tlet ambientLight = new THREE.AmbientLight( 0xffffff, 0.8 );// 0xcccccc\n\t\t\t\tscene.add( ambientLight );\n\t\t\t\tlet directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );\n\t\t\t\tdirectionalLight.position.set( -3, 0, 5 ).normalize();\n\t\t\t\tscene.add( directionalLight );\n        \n        // let spotLight = new THREE.PointLight( 0xffffff, 0.6, 100 );\n        // light.position.set( 0, 0, 0 );\n        // scene.add( spotLight );\n        \n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer({antialias: true, alpha: true});\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.domElement.style.position = \"absolute\";\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n        \n        // helpers\n        let directionalLighthelper = new THREE.DirectionalLightHelper( directionalLight, 200 );\n        // scene.add( directionalLighthelper );\n        \n        // var CameraHelper = new THREE.CameraHelper( camera );\n        // scene.add( CameraHelper );\n\n        // var axesHelper = new THREE.AxesHelper( 400 );\n        // scene.add( axesHelper );\n\n//         var size = 300;\n//         var divisions = 300;\n\n//         var gridHelper = new THREE.GridHelper( size, divisions );\n//         scene.add( gridHelper );\n        \n       \n        // orbit\n        let orbit = new THREE.OrbitControls( camera, renderer.domElement );\n        orbit.enableZoom = false;\n\t\t\t\t\n        // stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n        \n\t\t// resize\n\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\t\t}\n\n\t\tfunction onWindowResize() {\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t}\n      // animate\n      function animate() {\n        requestAnimationFrame( animate );\n        render();\n        stats.update();\n      }\n      function render() {\n        let delta = clock.getDelta();\n        if ( logo !== undefined ) {\n          logo.rotation.z += delta * 0.4;\n          logo.rotation.y += delta * 0.1;\n        }\n        renderer.render( scene, camera );\n      }\n\n// --------------------------------------------------star sky-----------------------------------\n// ------------------------------------------------------------------------------------------------\n\nlet canvas;\nvar context;\nvar screenH;\nvar screenW;\nvar stars = [];\nvar staticStars = [];\nvar staticSMStars = [];\nvar fps = 60;\nvar numStars = 40;\nvar numStaticStars = 100;\nvar numSMStaticStars = 60;\n\n$('document').ready(function() {\n  \n  // Calculate the screen size\n\tscreenH = $(window).height();\n\tscreenW = $(window).width();\n  \n\t\n\t// Get the canvas\n\tcanvas = $('#space');\n\t\n\t// Fill out the canvas\n\tcanvas.attr('height', screenH);\n\tcanvas.attr('width', screenW);\n\tcontext = canvas[0].getContext('2d');\n\n\tcontext.globalCompositeOperation='destination-over';\n  \n  // Create static stars\n\t\n  for (var i = 0; i < numStaticStars; i++) {\n\t\tvar x = Math.round(Math.random() * screenW);\n\t\tvar y = Math.round(Math.random() * screenH);\n    var size = 2;\n    \n    var staticStar = new Star(x, y, size);\n    staticStars.push(staticStar);\n  }\n  \n  // Create static small stars\n  \n    for (var i = 0; i < numSMStaticStars; i++) {\n\t\tvar x = Math.round(Math.random() * screenW);\n\t\tvar y = Math.round(Math.random() * screenH);\n    var size = 1;\n      \n    var staticSMStar = new Star(x, y, size);\n    staticSMStars.push(staticSMStar);\n  }\n  \n\t// Create dynamic stars\n\tfor (var i = 0; i < numStars; i++) {\n\t\tvar x = Math.round(Math.random() * screenW);\n\t\tvar y = Math.round(Math.random() * screenH);\n\t\tlet opacity = Math.random();\n    var size = 3;\n\t\tvar star = new Star(x, y, size, opacity);\n\t\t\n\t\t// Add the the stars array\n\t\tstars.push(star);\n\t}\n  \n  // console.log(star);\n  // console.log(staticStar);\n  // console.log(staticSMStar);\n\t\n\tanimateInterval = setInterval(animateStars, 1000 / fps);\n});\n\n/**\n * Animate the canvas\n */\nfunction animateStars() {\n\tcontext.clearRect(0, 0, screenW, screenH); //\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\t$.each(stars, function() {\n\t\tthis.draw(context);\n\t});\n  \t$.each(staticStars, function() {\n\t\tthis.drawStatic(context);\n\t});\n  \t$.each(staticSMStars, function() {\n\t\tthis.drawStatic(context);\n\t});\n}\n\n/* stop Animation */\nfunction stopAnimation() {\n     clearInterval(animateInterval);\n}\n\n// stopAnimation();\n\nfunction Star(x, y, size, opacity) {\n\tthis.x = parseInt(x);\n\tthis.y = parseInt(y);\n\tthis.opacity = opacity;\n  \tthis.size = size;\n\tthis.factor = 1;\n\tthis.increment = Math.random() * .03;\n}\n\nStar.prototype.draw = function() {\n\tcontext.rotate((Math.PI * 1 / 10));\n\t\n\t// Save the context\n\tcontext.save();\n\t\n\t// move into the middle of the canvas, just to make room\n\tcontext.translate(this.x, this.y);\n\t\n\t// Change the opacity\n\tif (this.opacity > 1) {\n\t\tthis.factor = -1;\n\t}\n\telse if (this.opacity <= 0) {\n\t\tthis.factor = 1;\n\t\t\n\t\tthis.x = Math.round(Math.random() * screenW);\n\t\tthis.y = Math.round(Math.random() * screenH);\n\t}\n\t\n\tthis.opacity += this.increment * this.factor;\n\n\n\tcontext.beginPath();\n  \tcontext.arc(10, 10, this.size, 0, Math.PI*2, true);\n  \tcontext.closePath();\n  \tcontext.fillStyle = 'rgba(255, 255, 200, ' + this.opacity + ')';\n  \tcontext.shadowColor = '#fff';\n  \tcontext.shadowBlur = 20;\n  \tcontext.shadowOffsetX = 2;\n  \tcontext.shadowOffsetY = 2;\n  \tcontext.fill();\n\tcontext.restore();\n};\n\nStar.prototype.drawStatic = function() {\n\tcontext.rotate((Math.PI * 1 / 10));\n\tcontext.save();\n\tcontext.translate(this.x, this.y);\n\tcontext.beginPath();\n    context.arc(10, 10, this.size, 0, Math.PI*2, true);\n    context.closePath();\n    context.fillStyle = 'rgba(255, 255, 200, 1)';\n    context.fill();\n\tcontext.restore();\n};","// parallax\n\nfunction Parallax(marg) {\n  \n\n  const THROTTLE_TIMEOUT = 50,\n\t    frontSection = document.querySelector('#front'),\n  \t  aboutSection = document.querySelector('#about'),\n  \t  aboutPicture = document.querySelector('.about__map'),\n      navbar = document.querySelector('.navbar');\n      this.marg = marg; \n  \n  return {\n    move: function (block, windowScroll, strafeAmount) {\n      let strafe = Math.ceil(windowScroll / -strafeAmount) + '%';\n      let margin = (parseInt(strafe) / 2) + '%';\n      let transformString = 'translate3d(0, '+ strafe +' , 0)';\n\n      this.strafe = strafe;\n      this.margin = margin;\n      \n      const style = block.style;      \n      style.transform = transformString;\n      style.webkitTransform = transformString;  \n\n      aboutPicture.style.marginTop = margin;\n      this.marg = margin;      \n    },\n\n    showMenu: function(block) {\n      (parseInt(this.strafe) < -30) ?  block.classList.remove('navbar--hidden') : block.classList.add('navbar--hidden');\n    },\n    \n    init: function (wScroll) {\n    \t// console.log(Date.now() - lastCall);\n    \t// if (Date.now() - lastCall >= THROTTLE_TIMEOUT && topCoord < 0) {\n\t      \tthis.move(frontSection, wScroll, -20);\n\t      \tthis.move(aboutSection, wScroll, 15);\n          this.showMenu(navbar);\n\t\t// }\n\t\t// lastCall = Date.now();\n    }  \n  }\n\n}\n\n\n// toggle front trigger\n\nconst frontTrigger = document.querySelector('#hamburger-10');\nconst navbar = document.querySelector('.navbar');\n\nfrontTrigger.addEventListener('click', function(e){\n  e.target.classList.toggle('is-active');\n  navbar.classList.toggle('navbar--hidden');\n});\n\n\n\n\n// navigation\n\n//function goToSection() {  mar\n  // $('.nav__link').on('click', function(e) {\n  //   e.preventDefault();\n  //   showSection($(this).attr('href'), true); // , mar\n  // });\n  \n  // showSection(window.location.hash, true); //, mar    \n//};\n\n$(document).ready(function() {\n\n//   const parallax = new Parallax();       \n//   let wScroll = window.pageYOffset;\n//   parallax.init(wScroll);\n//   console.log(parallax.marg);\n\n$('.nav__link').on('click', function(e) {\n  e.preventDefault();\n  showSection($(this).attr('href'), true); // , mar\n});\n  \nshowSection(window.location.hash, true); //, mar\n\ntoTop();\n\n});//ready\n  \n  // $(window).scroll(function() {\n  //   checkSection();\n  // });\n\n\nfunction toTop(){\n  let logoLink = $('.navbar-toplik');\n  logoLink.on('click', function(e) {\n    e.preventDefault();\n    showSection($(this).attr('href'), true);\n  });\n};\n\n// init section offsets\n\nlet sectionsObjs = {};\n\n(function createOffsetsMap () {  \n  function storeOffsets(sekcia, offset) {\n    sectionsObjs[sekcia] = offset;\n  }\n  $('section').each(function(i, elem){\n     return storeOffsets(elem.id, elem.offsetTop);\n  })\n})();\n\n\n\n\n// on scroll\n\nfunction showSection(section, isAnimate, off) {\n  let direction = section.replace(/#/, '');\n    let reqSection, reqSectionPos;\n    for(let sectionsObj in sectionsObjs){\n      if(sectionsObj === direction) {\n        reqSectionPos = sectionsObjs[sectionsObj]\n      }\n    }\n\n  let position  = reqSectionPos;\n  // console.log($(window).height()/parseInt(off)/100);\n  // console.log(off);\n    if(isAnimate) {\n    $('body, html').animate({scrollTop: position}, 500); // + $(window).height()/(parseInt(off)/100)\n  } else {\n    $('body, html').animate({scrollTop: position}); // + $(window).height()/(parseInt(off)/100)\n  }\n}\n\n  \n// function checkSection() {\n//     $('section').each(function() {\n  \n//       let $this = $(this),\n//         topEdge = $this.offset().top - 68,\n//         bottomEdge = topEdge + $this.height(),\n//         wScroll = $(window).scrollTop();\n  \n//       if(topEdge < wScroll && bottomEdge > wScroll) {\n//         let currentId = $this.data('section'),\n//         reqlink = $('.nav__link').filter('[href=\"#' + currentId + '\"]');\n//         reqlink.closest('.nav__item').addClass('nav__item--active').siblings().removeClass('nav__item--active');\n//         window.location.hash = currentId;\n//       }\n//     })\n//   }\n\n\n// scroll events\n\n\n  window.onscroll = function() {\n    const parallax = new Parallax();       \n    let wScroll = window.pageYOffset;\n    parallax.init(wScroll);\n    // goToSection();\n    // console.log(parallax.marg);\n    // checkSection();\n  };\n\n\n\n// hover project images\n\nlet projectImages = document.querySelectorAll('.projects-gallery__item');\n\n[].forEach.call(projectImages, function(image){\n  let projectCaption = image.querySelector('.projects-gallery__caption');\n    image.addEventListener('mouseenter', function(){\n      projectCaption.classList.add('projects-gallery__caption--active');\n    }); \n    image.addEventListener('mouseleave', function(){\n      projectCaption.classList.remove('projects-gallery__caption--active');\n    }); \n});\n\n// hover partners images\n\nconst partnerContainer = document.querySelector('.partners');\nconst partnerImages = $('.partners__img');\n\npartnerImages.on('mousemove', function(evt){\n  $(this).addClass('partners__img--active');\n  let otherImages = $(this).closest('PICTURE').siblings().find('.partners__img');\n  otherImages.each(function(){\n    $(this).removeClass('partners__img--active');\n  })\n});\n\n\n//map init\n\nymaps.ready(initMap);\nvar myMap, \n    myPlacemark;\n\nfunction initMap(){ \n    myMap = new ymaps.Map(\"map\", {\n        center: [60.032975, 30.323807],\n        zoom: 15\n    }); \n    myMap.behaviors.disable('scrollZoom');\n    \n    myPlacemark = new ymaps.Placemark([60.032524, 30.323270], {\n        hintContent: 'Форум!',\n        balloonContent: 'Энгельса 109'\n    });\n    \n    myMap.geoObjects.add(myPlacemark);\n}\n\n\n"]}